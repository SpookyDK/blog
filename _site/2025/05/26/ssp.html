<h1 id="del-1-produktudvikling">Del 1: Produktudvikling</h1>
<h2 id="sp1">SP1</h2>
<h3 id="hvad-er-det-prim√¶re-form√•l-med-opportunity-identification-processen-og-hvad-er-de-vigtigste-output-beskriveksemplificer-hvordan-man-kan-udf√∏re-processen">Hvad er det prim√¶re form√•l med opportunity identification processen og hvad er de vigtigste output? Beskriv/eksemplificer hvordan man kan udf√∏re processen.</h3>
<p>En del af frontend, der er forkel p√• vores ide og en opportunity, Ide er en impulse, opportunity er markeds tilpasset.<br />
En god opportunity skal overkomme en kvalitets barrier.<br />
Disse opportunities kan komme internt eller eksternt fra.<br />
Opprtunity horizons.  Hensyn til Computeren<br />
Horizont 1 = Sm√• forbedringer<br />
Horizont 2 = nye l√∏sninger / teknologier, eller ramme et andet marked, som til b√∏rn.<br />
Horizont 3 = Innovative l√∏sninger, Iphone, Homeassistant, Computeren.</p>

<p>Step by step<br />
Tragt formet, tournament<br />
<strong>Step 1:</strong> Innovation Charter, / catagori<br />
Balance mellem katagori st√∏rrelse og beg√¶nsning og overskuelighed.<br />
<strong>Step 2:</strong> Idea Generation<br />
Unders√∏ge konkurrenter, nye teknologier, snakker med kunder, studerer markedet, find ulemper med nuv√¶rende product.<br />
<strong>Step 3:</strong> Screen Ideas
Fjern urimelige ideer, er dette faktisk muligt.<br />
<strong>Step 4:</strong> Uddyb gode ideer
Unders√∏ge similare produkter, estimere markedet, hvordan kan dette egentligt udf√∏res, sm√• prototyber.<br />
<strong>Step 5:</strong> Select Candidates<br />
Sammenlign mellem criterier, og kan vi faktisk lave dette.<br />
<strong>Output</strong> <br />
Key product features, business goals.</p>

<p>Hvad ved jeg at jeg ikke ved, og hvad ved jeg</p>
<h3 id="er-det-radikalt-nye-produkter-altid-det-bedste-m√•l-hvad-er-fordelen-og-ulempen-ved-radikalt-nye-produkter">Er det radikalt nye produkter altid det bedste m√•l? Hvad er fordelen og ulempen ved radikalt nye produkter?</h3>
<p>Ikke udnyttet marked, dyrer l√∏sning / mere udvikling / H√∏j risiko, ikke bevidst marked.</p>
<h2 id="sp2">SP2</h2>
<h3 id="hvad-kan-vanskeligg√∏re-indhentningen-af-customer-needs-hvorfor-er-indhentningen-af-disse-et-s√¶rligt-vigtigt-step-i-produktudviklingsprocessen">Hvad kan vanskeligg√∏re indhentningen af customer needs? Hvorfor er indhentningen af disse et s√¶rligt vigtigt step i produktudviklingsprocessen?</h3>
<p>Det er vigtigt at vide hvad kunderne har brug for, da i sidste ende er det kunderne der bestemmer om produktet skal have success.<br />
Men det kan v√¶re sv√¶rt da kunder ikke altid ved hvad de vil have, og hvem er dine kunder egentligt<br />
S√¶tter udgangspunkt for kravspecifikationen.<br />
<strong>4 steps</strong> 
<strong>Step 1</strong>  Gather Raw data<br />
Intervies, focus grupper, observering a customers(Xbox kinect), Surveys<br />
Der er forskel p√• kunder, den gennemsnitlige og elite kunder.    Jeg er elite bruger af min laptop. Pas p√• elite brugerne.
Brand loyalty.
Interview guide, hvad er milj√∏et, go with the flow, hver objektiv, probs.
Man f√•r customer statements<br />
<strong>Step 2</strong>  Interpret Data <br />
Det vi gjorde efter at have snakket med christoffer.
Omskrive og fortolke kunde statements til hvad produktet kan.
Undg√• l√∏snings mode. Undg√• must and should.
Ikke filtrer endnu.<br />
<strong>Step 3</strong>  Organise Needs <br />
Grupper statements, og sorter data.
Ikke fjern modsigende statements endnu.<br />
<strong>Step4</strong>  Prioritise Needs<br />
Prioriter p√• baggrund af hvor mange gange det er blevet sagt.</p>
<h3 id="hvilke-andre-interessenter-kunne-v√¶re-relevante-at-indhente-krav-til-produktet-fra-hvordan-vil-du-g√∏re-det">Hvilke andre interessenter kunne v√¶re relevante at indhente krav til produktet fra? Hvordan vil du g√∏re det?</h3>
<p>Konkurrenter(Hvad kan konkurrenterne), desk study,  Lego, kunden er for√¶ldre, barn er bruger.
Butikker og resellers, Hvad mener vi selv mangler intern</p>
<h2 id="sp3">SP3</h2>
<h3 id="hvilke-typer-af-modularitet-findes-der-for-en-modul√¶r-produktarkitektur-giv-et-par-eksempler-fra-konkrete-produkter">Hvilke typer af modularitet findes der for en modul√¶r produktarkitektur? Giv et par eksempler fra konkrete produkter.</h3>
<p>Platform modularitet.  Noget produkter deler kan udvikles for sig selv. F.eks VW elbil platform, s√• batterierne er ens. AMD‚Äôs Chiplets, som bruges i alle produkter, fra b√¶rbar til server.
Fuldt modul√¶r.
Semi modul√¶r (smartphones er godt eksempel)
Integral. Helt integreret.<br />
<strong>Slot-Modular</strong> (Smarphone) Ting kan connect 1 sted p√• det samlede produkt.<br />
<strong>Bus-Modular</strong> (server/desktop er lidt begge) Alt forbindes til et samlet punkt / ens interface.<br />
<strong>Sectional-Modular</strong> (Google tingen) Alle moduler er independent, Lego, ting kan stables.</p>

<h3 id="er-en-modul√¶r-produktarkitektur-altid-en-fordel-er-det-tilf√¶lde-hvor-en-integreret-arkitektur-er-en-fordel-giv-gerne-eksempler">Er en modul√¶r produktarkitektur altid en fordel? Er det tilf√¶lde hvor en integreret arkitektur er en fordel? Giv gerne eksempler.</h3>
<p>integreret architecture kan give et ‚Äúbedre‚Äù ende produkt, men kan komme med udviklings udfordringer.
Men samtidigt kan modul√¶r arkitektur g√∏re alle delene extra specialle da alle ikke beh√∏ver et overblik over hele l√∏sningen.
Mindre produkter. Modul√¶r giver et formt for overhead, ligesom Object orienteret ogs√• kan g√∏re.
eksempel (Ram slots er modul√¶re, men har h√∏jere latens og laver clock speeds).
Fordel er at man kan nemt customize til bestemt cusomer.</p>
<h2 id="sp4">SP4</h2>
<h3 id="i-kurset-har-vi-anvendt-en-screening--scoring-matrix-til-at-udv√¶lge-et-endeligt-koncept-hvad-er-styrken-ved-denne-metode-hvad-kunne-alternative-metoder-v√¶re-til-at-v√¶lge-et-koncept">I kurset har vi anvendt en ‚Äùscreening &amp; scoring‚Äù matrix til at udv√¶lge et endeligt koncept. Hvad er styrken ved denne metode? Hvad kunne alternative metoder v√¶re til at v√¶lge et koncept?</h3>
<p>Et godt koncept men d√•rligt udf√∏rt kan v√¶re sucess, men d√•rligt koncept er altid d√•rligt.<br />
Del produktet op i funktioner / behov(Bilen interrior beh√∏ves ikke at h√¶nge sammen med motoren).<br />
Blackbox, Input &amp; output, og hvad sker der s√• i denne kasse?.<br />
Hvordan bliver dette i kassen s√• gjort, teknisk specifikt. Unders√∏g eksiterende l√∏sninger, snak med experter, unders√∏g specifikke technologier.<br />
Unders√∏g internt, technologisk, og brug de egenskaber gruppe medlemmerne har.<br />
Disse koncepter kan s√• blive valgt ved screening &amp; scoring.<br />
steps = Prepare matrix - Rate - Rank - Combine(Merge nogle gode ting man opdager undervejs) - Select:<br />
Tag udgangpunkt i 1 koncept, s√¶t til lig 0, og sammenlign anre koncepter i forhold til dette.<br />
Nu kan vi v√¶gte v√¶rdierne, og derfor prioritere.<br />
Scoring og v√¶gtning kan hurtigt v√¶gte ting mod preferrencer. <br />
Det er vigtigt at have t√¶nkt over v√¶gtende, og ikke √¶ndre v√¶gtende for at prioritere andet produkt.<br />
Kr√¶ver en god analyse af features, og krav.<br />
P√• dette tidpunkt kan det v√¶re sv√¶rt at vurdere hvad man b√∏r scorer de forskellige koncepter.<br />
Alternativ, Vi begyndte at arbejde p√• forskellige ting samtidigt, og l√∏bende estimere l√∏sninger.</p>
<h3 id="hvad-kunne-du-g√∏re-for-at-√∏ge-trov√¶rdigheden-af-de-enkelte-scorer-i-matrixen">Hvad kunne du g√∏re for at √∏ge trov√¶rdigheden af de enkelte scorer i matrixen?</h3>
<p>Underst√∏tte dem med kilder og argumentationer, eller basere dem p√• customer needs unders√∏gelser.<br />
F√• kunder til at score koncepterne, og give deres mening p√• det.</p>
<h2 id="sp5">SP5</h2>
<h3 id="hvad-er-fordelene-ved-at-f√∏lge-en-struktureret-metode-til-produktudvikling-hvad-risikerer-man-ved-ikke-at-g√∏re-det">Hvad er fordelene ved at f√∏lge en struktureret metode til produktudvikling? Hvad risikerer man ved ikke at g√∏re det?</h3>
<p>Man risikerer at man ender ud med et produkt der ikke lever op til kravene, eller ikke har nogle kunder.<br />
mere‚Ä¶
SP5 ‚Äì Struktur i produktudvikling
Hvad er fordelene ved at f√∏lge en struktureret metode til produktudvikling? Hvad risikerer man ved ikke at g√∏re det?</p>

<p>Fordele:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M√•lrettethed og fokus ‚Äì En struktureret metode sikrer, at man arbejder mod klart definerede m√•l, s√•som kundebehov, tekniske krav og forretningsm√•l.

Tids- og ressourceeffektivitet ‚Äì Ved at f√∏lge faser som behovsanalyse, konceptudvikling, prototype og test undg√•r man spildarbejde.

Bedre kommunikation i teamet ‚Äì Struktur giver et f√¶lles sprog og forventningsafstemning i tv√¶rfaglige teams.

Dokumentation og l√¶ring ‚Äì Man skaber sporbarhed og mulighed for evaluering og forbedring til fremtidige projekter.

Kundecentrering ‚Äì En god metode (f.eks. Stage-Gate, V-model eller Ulrich &amp; Eppinger) inkluderer kundebehov i processen, hvilket √∏ger chancen for succes p√• markedet.
</code></pre></div></div>

<p>Risici ved ikke at f√∏lge en struktureret metode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Udvikling af et produkt uden marked (ingen eftersp√∏rgsel).

Fejl og omarbejdning pga. manglende kravspecifikationer.

Manglende integration mellem delsystemer.

Uklare roller og ansvar ‚Üí d√•rlig teamkoordinering.

Projektet l√∏ber l√∏bsk i tid og budget. ### Hvad er nogle af de st√∏rste faldgrupper som produktudviklingsteam i forbindelse med processen? Tech-demoer i stedet for rigtige produkter
‚Äì Fokus p√• teknologi frem for brugerbehov. Det kan f√∏re til, at man laver noget "smart", som ingen har brug for.

Springe behovsanalysen over
‚Äì Mange teams g√•r direkte til l√∏sning, uden at forst√• kundens egentlige problemer. Det f√∏rer ofte til forkerte l√∏sninger.

D√•rlig kravspecifikation
‚Äì Uklare eller ikke-prioriterede krav giver konflikt senere i projektet, is√¶r ved test og implementering.

Ingen iterativ test og feedback
‚Äì Man udvikler hele produktet uden at teste det l√∏bende. S√• opdager man fejlene for sent og m√• redesigne.

Manglende involvering af relevante interessenter
‚Äì Hvis marketing, produktion eller kunder ikke inddrages, kan man ende med et produkt der er sv√¶rt at s√¶lge eller producere.

For lidt dokumentation
‚Äì Uden tilstr√¶kkelig dokumentation kan man ikke overlevere viden, og fremtidig vedligehold bliver sv√¶r.

Scope creep
‚Äì Projektets m√•l udvides hele tiden uden kontrol, s√• man mister fokus og overskrider budget og tid.
</code></pre></div></div>

<h1 id="del-2-kravsspecifikation-og-system-design">Del 2: Kravsspecifikation og system design.</h1>
<h2 id="sp6">SP6</h2>
<h3 id="hvad-er-et-use-case-diagram-hvilke-elementer-best√•r-det-af-hvad-bruger-man-det-til-hvorn√•r-anvender-man-use-case-diagrammer-tegn-eller-vis-eksempeleksempler">Hvad er et use case diagram? Hvilke elementer best√•r det af? Hvad bruger man det til? Hvorn√•r anvender man use case diagrammer? Tegn eller vis eksempel/eksempler.</h3>
<p>Hvad er et use case diagram?</p>

<p>Et use case-diagram viser akt√∏rer (brugere eller andre systemer) og deres interaktioner (use cases) med systemet. Det beskriver funktionerne (use cases), som systemet skal levere, og hvordan brugerne interagerer med dem.<br />
<strong>Hvilke elementer best√•r det af?</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System (gr√¶nse) ‚Äì Angivet som en rektangul√¶r boks, der indeholder use cases. Det er d√©t system, man beskriver.

Use case (brugssituation) ‚Äì En oval der beskriver en funktion (f.eks. "Log ind", "Bestil produkt").

Akt√∏r (actor) ‚Äì En stick-figur, der repr√¶senterer en bruger eller andet system, der interagerer med systemet.
</code></pre></div></div>

<p><strong>Relationer:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Association (linje): Forbindelse mellem akt√∏r og use case.

Include: Angiver at en use case altid inkluderer en anden.

Extend: Angiver at en use case nogle gange udvides med en anden, fx afh√¶ngigt af betingelser.
</code></pre></div></div>

<p><strong>Hvad bruger man det til?</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F√• overblik over funktionelle krav til et system.

Kommunikere med interessenter (brugere, kunder, udviklere).

Dokumentere brugerbehov og systemets forventede opf√∏rsel.

Analyse og design af software og interaktionsflow.
</code></pre></div></div>

<p><strong>Hvorn√•r anvender man use case-diagrammer?</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tidligt i kravspecifikationsfasen i systemudvikling.

Under analyse og design.

N√•r man vil visualisere brugerinteraktioner og sikre, at alle funktioner er d√¶kket.

Som supplement til user stories og funktionelle krav ### Hvad er en use case beskrivelse? Hvad er vigtigt i en s√•dan beskrivelse? Hvordan relaterer disse sig til krav specifikationerne? Hvorn√•r udarbejder man beskrivelserne? Hvem udarbejder dem? Giv eksempler. **Hvad er en use case-beskrivelse?**
</code></pre></div></div>

<p>En use case-beskrivelse er en tekstuel (detaljeret) beskrivelse af, hvordan en akt√∏r interagerer med systemet for at opn√• et bestemt m√•l. Hvor use case-diagrammer viser overblik, g√•r beskrivelsen i dybden med trin-for-trin scenarier.
<strong>Hvad er vigtigt i en use case-beskrivelse?</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>En god use case-beskrivelse indeholder typisk f√∏lgende elementer:  
Felt	Beskrivelse  
Navn	Kort og pr√¶cis titel (f.eks. "Log ind")  
M√•l	Hvad akt√∏ren √∏nsker at opn√•  
Prim√¶r akt√∏r	Den bruger eller system der initierer use casen  
Interessenter og behov	Hvem har interesse i funktionen og hvorfor  
Foruds√¶tninger	Hvad skal v√¶re opfyldt f√∏r handlingen starter  
Efterf√∏lgende tilstand	Hvad er opn√•et, hvis use casen lykkes  
Hovedforl√∏b (normal flow)	De vigtigste trin i interaktionen  
Alternative forl√∏b / Undtagelser	Hvad sker der, hvis noget g√•r galt eller afviger  
Frekvens (valgfrit)	Hvor ofte use casen typisk forekommer   **Hvordan relaterer use case-beskrivelser sig til kravspecifikationer?**

Use case-beskrivelser konkretiserer funktionelle krav fra kravspecifikationen.

De fungerer som en slags bro mellem overordnede krav og teknisk design.

G√∏r det nemt at teste og verificere, om krav er opfyldt (basis for test cases).

Hj√¶lper med at prioritere funktionalitet baseret p√• brugerens behov.
</code></pre></div></div>

<p><strong>Hvorn√•r og af hvem udarbejdes de?</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sp√∏rgsm√•l	Svar
Hvorn√•r?	I krav- og analysefasen ‚Äì gerne f√∏r design og kodning starter.
Hvem?	Typisk systemanalytikere, UX-designere, eller produktudviklere ‚Äì ofte i samarbejde med kunden eller slutbrugere.
‚úèÔ∏è Eksempel p√• use case-beskrivelse
</code></pre></div></div>

<p><strong>Use case: Bestil produkt</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M√•l: Kunden √∏nsker at bestille et produkt online.

Prim√¶r akt√∏r: Kunde

Interessenter: Kunden (hurtig levering), webshop (salg), lager (ordrebehandling)

Foruds√¶tning: Kunden er logget ind og har fundet et produkt.

Efterf√∏lgende tilstand: Ordren er registreret og bekr√¶ftet.
</code></pre></div></div>

<p>Hovedforl√∏b:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Kunden klikker p√• "K√∏b" p√• produktet.

Systemet viser kurven og totalbel√∏b.

Kunden klikker p√• "G√• til betaling".

Kunden indtaster leverings- og betalingsoplysninger.

Kunden klikker "Bekr√¶ft".

Systemet validerer oplysningerne og opretter ordren.

Kunden f√•r bekr√¶ftelse p√• ordren.
</code></pre></div></div>

<p>Alternative forl√∏b:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4a. Kunden v√¶lger at betale med MobilePay.

6a. Hvis betaling mislykkes ‚Üí system viser fejl og beder om ny metode. ## SP7 ### Hvad karakteriserer gode krav? Giv eksempler p√• gode og d√•rlige krav. Hvor i V-modellen finder vi hvilke typer af krav? Med hvem udarbejder vi krav og p√• hvilke m√•de sikrer vi at vi f√•r samtlige vigtige krav med i kravspecifikationen? **Hvad karakteriserer gode krav?**
</code></pre></div></div>

<p><strong>Gode krav skal v√¶re:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Kvalitet	Forklaring
Entydige	Kravet skal kun kunne forst√•s p√• √©n m√•de (ingen tvetydighed).
Testbare / Verificerbare	Det skal v√¶re muligt at afpr√∏ve, om kravet er opfyldt.
N√∏dvendige	Kun krav, der har reel v√¶rdi for systemet eller brugeren.
Tydelige og pr√¶cise	Ikke vage begreber som "hurtig", "let" eller "bedre".
Sporbare	Man skal kunne se, hvor kravet stammer fra (f.eks. en kundeanmodning).
Konsistente	Krav m√• ikke modsige hinanden.
</code></pre></div></div>

<p><strong>Eksempler p√• gode og d√•rlige krav</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D√•rligt krav	Hvorfor d√•rligt	Godt krav (forbedret)
"Systemet skal v√¶re hurtigt."	Uklart, subjektivt	"Systemet skal svare inden for 1 sekund i 95‚ÄØ% af alle tilf√¶lde."
"Brugeren skal nemt kunne oprette en profil."	Ikke m√•lbart	"Brugeren skal kunne oprette en profil via en formular med maks. 5 felter."
"Appen skal v√¶re moderne."	For vag og upr√¶cis	"Appen skal f√∏lge Android Material Design 3 retningslinjer."
</code></pre></div></div>

<p><strong>Hvor i V-modellen findes kravene?</strong></p>

<p>V-modellen beskriver systemudvikling som en proces, hvor hver fase p√• venstresiden har en tilsvarende testfase p√• h√∏jresiden. Krav findes p√• venstresiden i starten af udviklingen:
Fase i V-modellen	Type krav
Brugerbehov (toppen)	Overordnede forretnings- og brugerkrav
Systemkrav	Funktionelle og ikke-funktionelle krav
Designkrav	Tekniske specifikationer for hvordan kravene opfyldes</p>

<p>P√• h√∏jresiden verificeres kravene gennem test: systemtest, integrationstest, enhedstest ‚Äì baseret direkte p√• kravene.
<strong>Med hvem udarbejder vi krav?</strong></p>

<p>Krav udarbejdes i samarbejde med:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Slutbrugere / kunder ‚Äì deres behov og √∏nsker er fundamentale.

Forretningsanalytikere / produktledere ‚Äì overs√¶tter behov til krav.

Udviklere / arkitekter ‚Äì vurderer realiserbarhed.

Testere ‚Äì sikrer at krav kan testes.

UX-designere ‚Äì bidrager til brugervenlighedskrav.
</code></pre></div></div>

<p>Hvordan sikrer vi, at vi f√•r alle vigtige krav med?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Workshops &amp; interviews med interessenter.

Observationer &amp; kontekstuel analyse ‚Äì se hvordan nuv√¶rende systemer bruges.

Brainstorming og kravindsamlingsteknikker (f.eks. MoSCoW, Kano).

Use cases og user stories ‚Äì hj√¶lper med at identificere funktionelle krav.

Prototyper og mockups ‚Äì skaber feedback og afd√¶kker oversete krav.

Sporbarhedsmatrix ‚Äì kobler krav til test, design og forretningsm√•l. ### Hvilke krav har vi til vores kravspecifikation? Hvordan sikrer vi at krav til krav er opfyldt? Hvordan bruger vi krav i efterf√∏lgende udviklingsproces? Hvordan forholder vi os til at skulle lave √¶ndringer i krav i de efterf√∏lgende tidsperioder i en udviklingsproces f.eks. hen mod slutningen af projektet? Giv eksempler. Hvilke krav har vi til vores kravspecifikation?
</code></pre></div></div>

<p><strong>En kravspecifikation skal v√¶re:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Krav til kravspecifikationen	Beskrivelse
Komplet	Alle relevante funktionelle og ikke-funktionelle krav skal v√¶re med.
Entydig	Hvert krav skal kun kunne forst√•s p√• √©n m√•de.
Testbar	Det skal v√¶re muligt at verificere hvert krav.
Sporbar	Hvert krav skal kunne spores til kilder (behov, interessenter) og til test, design og kode.
Struktureret og prioriteret	Kravene skal v√¶re velorganiserede og eventuelt prioriteret (f.eks. MoSCoW: Must, Should, Could, Won‚Äôt).
Versionsstyret	Man skal kunne f√∏lge √¶ndringer over tid (hvem √¶ndrede hvad og hvorn√•r). **Hvordan sikrer vi, at ‚Äúkrav til krav‚Äù er opfyldt?**

Review og godkendelse
‚Äì Gennemg√• kravene med interessenter og f√• dem godkendt. Brug evt. checklister (f.eks. IEEE-830).

Sporbarhedsmatrix
‚Äì Kortl√¶g alle krav til relaterede designbeslutninger og testcases.

Brug af skabeloner og v√¶rkt√∏jer
‚Äì Kravspecificeringsv√¶rkt√∏jer (f.eks. Jira, IBM DOORS) hj√¶lper med konsistens, dokumentation og versionsstyring.

Testbarhedsanalyse
‚Äì Involv√©r testere tidligt: ‚ÄúKan dette krav testes?‚Äù Hvis ikke, skal det omskrives.

Roller og ansvar
‚Äì Tydelige ejere af kravene sikrer ansvar for indhold og √¶ndringer.
</code></pre></div></div>

<p><strong>Hvordan bruger vi krav i den efterf√∏lgende udviklingsproces?</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Kravene er fundamentet for hele udviklingsprocessen:
Procesfase	Brug af krav
Design	Udviklere og arkitekter bruger krav til at beslutte systemets struktur og komponenter.
Implementering	Kode baseres p√• funktionelle krav.
Test	Testcases laves ud fra krav (accepttest, systemtest).
Verifikation og validering	Bruges til at afg√∏re, om det udviklede system matcher krav og behov.
Dokumentation og overlevering	Krav dokumenterer, hvad systemet skal kunne ‚Äì bruges til support og videreudvikling. **Hvordan h√•ndterer vi √¶ndringer i krav sent i udviklingsforl√∏bet?**
</code></pre></div></div>

<p>√Ündringer sker ofte ‚Äì men sent i processen er de dyrere og risikofyldte.
S√•dan h√•ndteres det:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Change Request-proces
‚Äì Formaliseret m√•de at foresl√•, evaluere og godkende √¶ndringer.

Impact analysis
‚Äì Hvad p√•virker √¶ndringen? Tid, test, funktionalitet, afh√¶ngigheder? Dette vurderes f√∏r godkendelse.

Sporbarhed
‚Äì Man kan hurtigt identificere, hvilke komponenter og testcases der ber√∏res.

Kommunikation
‚Äì Inform√©r hele teamet om √¶ndringer (dev, test, design, kunde).

Agile eller iterativ udvikling
‚Äì Hvis muligt: arbejd i iterationer, s√• krav kan justeres l√∏bende med mindre risiko.
</code></pre></div></div>

<p><strong>Eksempler p√• √¶ndringer i krav og deres konsekvenser</strong><br />
√Ündring i krav	Konsekvens	H√•ndtering
‚ÄúBrugeren skal kunne betale med MobilePay‚Äù tilf√∏jes sent	Integration med ny betalingsgateway ‚Üí ekstra udvikling og test	Change request, teknisk vurdering, planjustering<br />
√Ündring af svartid fra 2 sek til 0.5 sek	Kr√¶ver optimering af backend og database	Reprioritering af performancefokus, evt. delvis opfyldelse<br />
Krav om at systemet skal virke offline	√Ündrer hele arkitekturen	Overvej version 2, lav business case for v√¶rdi/kost</p>
<h2 id="sp8">SP8</h2>
<h3 id="hvordan-deler-man-effektivt-krav-op-i-funktionelle-moduler-hvad-definerer-et-modul-hvad-kan-vi-bruge-modulariseringen-til-giv-eksempler-gerne-p√•-tavle">Hvordan deler man effektivt krav op i funktionelle moduler? Hvad definerer et modul? Hvad kan vi bruge modulariseringen til? Giv eksempler, gerne p√• tavle.</h3>
<p><strong>Hvordan deler man krav op i funktionelle moduler?</strong><br />
<strong>Grundid√©:</strong></p>

<p>Du opdeler systemet i mindre funktionelle enheder (moduler), som hver is√¶r d√¶kker √©t specifikt omr√•de af funktionaliteten.
<strong>Metode:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Identific√©r hovedfunktioner / use cases
‚Äì Hvad skal systemet kunne?

Grupp√©r relaterede krav
‚Äì Krav, der h√∏rer sammen funktionelt, samles.

Opdel efter ansvar og gr√¶nseflader
‚Äì Hvert modul skal have et klart ansvar og minimalt overlap.

Overvej brugerroller og systemakt√∏rer
‚Äì Hvad har forskellige brugere brug for at g√∏re? Dette guider opdelingen.
</code></pre></div></div>

<p><strong>Hvad definerer et modul?</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Et modul er:
Egenskab	Forklaring
Afgr√¶nset funktionelt omr√•de	L√∏ser √©n tydelig opgave (f.eks. "Brugerh√•ndtering")
Indeholder relaterede krav og funktioner	F.eks. "Login", "Opret bruger", "Nulstil adgangskode"
Har en veldefineret gr√¶nseflade (API eller UI)	Moduler kommunikerer gennem veldefinerede kald eller sk√¶rme
Kan udvikles og testes uafh√¶ngigt	G√∏r teams mere effektive og reducerer kompleksitet
</code></pre></div></div>

<p><strong>Hvad kan vi bruge modularisering til?</strong>
Fordel	Beskrivelse<br />
‚úÖ Overblik	Krav bliver lettere at forst√• og styre<br />
‚úÖ Genbrug	Moduler kan genbruges i andre projekter<br />
‚úÖ Parallelt arbejde	Teams kan arbejde p√• forskellige moduler samtidigt<br />
‚úÖ Fejlisolering	Fejl lokaliseres hurtigere<br />
‚úÖ √Ündringer bliver lettere	√Ündringer i √©t modul p√•virker ikke hele systemet<br />
‚úÖ Skalerbarhed	Systemet kan lettere vokse med nye funktioner</p>
<h3 id="hvad-er-en-gr√¶nseflade-hvordan-bliver-man-enig-om-en-gr√¶nseflade-hvem-er-involveret-i-at-definere-gr√¶nseflader-hvilke-fordeleulemper-er-der-ved-at-definere-gr√¶nseflader-tidligtsent-i-et-projektforl√∏b-giv-eksempler">Hvad er en gr√¶nseflade? Hvordan bliver man enig om en gr√¶nseflade? Hvem er involveret i at definere gr√¶nseflader? Hvilke fordele/ulemper er der ved at definere gr√¶nseflader tidligt/sent i et projektforl√∏b? Giv eksempler</h3>

<p><strong>Typer af gr√¶nseflader:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Type	Eksempel
Teknisk gr√¶nseflade	API mellem backend og frontend
Fysisk gr√¶nseflade	Stikforbindelse, sk√¶rm, knap
Brugergr√¶nseflade (UI)	App-sk√¶rmbilleder, menuer, formularer
Procesgr√¶nseflade	Overlevering mellem to teams eller systemer i et workflow **Hvordan bliver man enig om en gr√¶nseflade?**

Identific√©r behov og afh√¶ngigheder
‚Äì Hvad har de to parter brug for fra hinanden?

Samarbejde og kommunikation
‚Äì Design, software, hardware, test og brugerrepr√¶sentanter skal involveres.

Brug specifikationer og diagrammer
‚Äì Brug f.eks.:

    Interface-specifikationer (API-dokumenter, wireframes)

    Sekvensdiagrammer, I/O-skemaer

Prototyper og mockups
‚Äì Visualisering af interaktion hj√¶lper parterne med at forst√• gr√¶nsefladen.
</code></pre></div></div>

<p><strong>Hvem er involveret i at definere gr√¶nseflader?</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Rolle	Bidrag
Systemarkitekt	Fastl√¶gger overordnede tekniske gr√¶nseflader
Softwareudviklere	Definerer f.eks. API‚Äôer mellem komponenter
Hardwareudviklere	Ved fysiske gr√¶nseflader (sensorer, knapper, porte)
UX-designere	Ved brugergr√¶nseflader (UI)
Testere	Sikrer at gr√¶nsefladen kan testes og valideres
Kunder/brugere	Ved brugerinteraktion eller systemintegration
‚è±Ô∏è Fordele og ulemper ved tidlig/sen definition
Timing	Fordele	Ulemper
Tidlig	- G√∏r parallel udvikling muligt
- Giver klar struktur
- Giver testmuligheder tidligere	- Risiko for √¶ndringer senere
- Kan l√•se fast i et forkert design
Sen	- Mere viden og erfaring
- Bedre tilpasning til reelle behov	- Forsinker udvikling
- Skaber afh√¶ngigheder og flaskehalse
- √òget risiko for misforst√•elser **Eksempler** **Teknisk eksempel (software):**

Et API mellem en webshop-frontend og backend:

    Gr√¶nsefladen definerer kald som: GET /products, POST /checkout

    Frontend- og backendteams arbejder parallelt, fordi gr√¶nsefladen er defineret tidligt
</code></pre></div></div>

<p><strong>Fysisk eksempel (produktdesign):</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>En elektrisk motor med en standardiseret stikforbindelse til styring:

    Gr√¶nsefladen er stiktypen + datasignaler

    Motor og styringsmodul kan udvikles hver for sig
</code></pre></div></div>

<p><strong>Brugergr√¶nseflade:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>En app har et loginmodul, som leverer brugerinfo til resten af systemet

    UI og backend skal blive enige om: Hvilke felter vises? Hvad sendes?
</code></pre></div></div>

<h1 id="del-3-implementering-og-test">Del 3: Implementering og test</h1>
<h2 id="sp9">SP9</h2>
<h3 id="hvad-er-kodestil-og-kodestruktur-for-hvem-er-dette-vigtigt-hvad-har-i-gjort-i-jeres-projekt-hvordan-bliver-man-enige-om-feks-brug-af-white-space-eller-tabs-giv-eksempler-p√•-forskellige-kodestilarter-der-kan-√∏ge-l√¶sevenligheden-og-eksempler-p√•-det-modsatte-der-mindsker-l√¶sevenligheden">Hvad er kodestil og kodestruktur? For hvem er dette vigtigt? Hvad har I gjort i jeres projekt? Hvordan bliver man enige om f.eks. brug af white space eller tab‚Äôs? Giv eksempler p√• forskellige kodestilarter der kan √∏ge l√¶sevenligheden, og eksempler p√• det modsatte (der mindsker l√¶sevenligheden).</h3>
<p><strong>Hvad er kodestil og kodestruktur?</strong>
<strong>Kodestil</strong></p>

<p>Kodestil handler om hvordan koden ser ud ‚Äì det visuelle og sproglige udtryk. Det d√¶kker fx:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Brug af indrykning (tabs vs. spaces)

Navngivning af variabler og funktioner (camelCase, snake_case)

Brug af mellemrum og linjeskift

Kommentarstil og placering

Placering af {} i funktioner og kontrolstrukturer
</code></pre></div></div>

<p>Eksempel p√• to forskellige kodestile i JavaScript:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Kodestil 1 (kompakt, men lidt sv√¶rere at l√¶se)
function add(a,b){return a+b;}

// Kodestil 2 (mere l√¶sbar)
function add(a, b) {
  return a + b;
}
</code></pre></div></div>

<p><strong>Kodestruktur</strong></p>

<p>Kodestruktur handler om hvordan koden er organiseret logisk:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Filstruktur (mappestruktur)

Moduler og komponenter

Funktionsopdeling (sm√•, genanvendelige funktioner)

Separation of concerns (logik adskilt fra pr√¶sentation og data)
</code></pre></div></div>

<p>Eksempel:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>projekt/
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îî‚îÄ‚îÄ userController.js
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îî‚îÄ‚îÄ userModel.js
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îî‚îÄ‚îÄ userRoutes.js
‚îî‚îÄ‚îÄ app.js
</code></pre></div></div>

<p><strong>For hvem er dette vigtigt?</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For hele teamet: Giver f√¶lles sprog og f√¶rre misforst√•elser.

For fremtidige udviklere: Koden bliver nemmere at vedligeholde.

For review og samarbejde: G√∏r kodegennemgang hurtigere og mere effektiv.

For test og debugging: En ensartet stil g√∏r det nemmere at finde fejl.
</code></pre></div></div>

<p>üí¨ Hvordan bliver man enige om stil (fx tabs vs. spaces)?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L√¶g f√¶lles retningslinjer fra starten:

    Brug fx Google Style Guide, Airbnb JS Guide, PEP8 (Python) osv.

Automatis√©r med linters og formateringsv√¶rkt√∏jer:

    Eksempler: ESLint, Prettier, Black (Python), clang-format

Lav en README.md eller CONTRIBUTING.md med stilregler

Brug Git pre-commit hooks til at tjekke stil f√∏r kode pushes
</code></pre></div></div>

<p>‚úÖ Eksempler p√• god kodestil (l√¶sevenlig)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def calculate_total(price, tax_rate):
    """Calculate total price including tax."""
    return price * (1 + tax_rate)

Klar funktion

Gode navne

Kommentar (docstring)

Lige mellemrum
</code></pre></div></div>

<p>‚ùå Eksempler p√• d√•rlig kodestil (ul√¶selig)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def ct(p,t):return p*(1+t)

D√•rlige navne

Ingen mellemrum

Ingen kommentar

Alt p√• √©n linje kamelCase, navngivning, function st√∏rrelse, nasa's krav. Vi havde b√•de python og C++, python blev tjekket via github action, c++ var mere skrevet s√• det man skrev lignede det der allerede stod. Manglede generelt m√•ske lidt konsistens. ### Hvad er objekt orienteret programmering? Hvad er en klasse i forhold til et objekt? Hvad er et klassediagram? Tegn gerne et simpelt et p√• tavlen og diskuter ud fra det tegnede diagram. **Hvad er objektorienteret programmering (OOP)?**
</code></pre></div></div>

<p>Objektorienteret programmering er en programmeringsparadigme, hvor man strukturerer kode omkring objekter, som repr√¶senterer ting, begreber eller enheder i virkeligheden.
<strong>N√∏gleprincipper i OOP:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Princip	Forklaring
Indkapsling	Data og funktioner gemmes sammen i objekter
Arv	En klasse kan arve egenskaber fra en anden
Polymorfi	Objekter kan opf√∏re sig forskelligt, selvom de deler samme interface
Abstraktion	Skjuler kompleksitet og viser kun n√∏dvendig information **Hvad er en klasse og et objekt?**
Begreb	Forklaring
Klasse	En skabelon eller blueprint for at lave objekter
Objekt	En konkret instans af en klasse med sine egne data
</code></pre></div></div>

<p>Eksempel i Python:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Dog:               # Klasse
    def __init__(self, name):
        self.name = name

    def bark(self):
        print(f"{self.name} says woof!")

my_dog = Dog("Fido")     # Objekt (instans af klassen)
my_dog.bark()            # Output: Fido says woof!
</code></pre></div></div>

<p><strong>Hvad er et klassediagram?</strong></p>

<p>Et klassediagram er en grafisk m√•de at vise klasser og deres relationer p√•. Det er en del af UML (Unified Modeling Language) og bruges i designfasen.
Klassediagrammet viser:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Klasser

Attributter (datafelter)

Metoder (funktioner)

Relationer mellem klasser (arv, association, komposition osv.)
</code></pre></div></div>

<p>Tegn et simpelt klassediagram p√• tavlen
Eksempel: Et system med Person og Student</p>

<p>+‚Äî‚Äî‚Äî‚Äî‚Äì+
|   Person     |
+‚Äî‚Äî‚Äî‚Äî‚Äì+
| - name       |
| - age        |
+‚Äî‚Äî‚Äî‚Äî‚Äì+
| + greet()    |
+‚Äî‚Äî‚Äî‚Äî‚Äì+
       ‚ñ≤
       |
   inherits
       |
+‚Äî‚Äî‚Äî‚Äî‚Äì+
|   Student    |
+‚Äî‚Äî‚Äî‚Äî‚Äì+
| - studentID  |
+‚Äî‚Äî‚Äî‚Äî‚Äì+
| + study()    |
+‚Äî‚Äî‚Äî‚Äî‚Äì+</p>

<p>Forklaring:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Person er en superklasse

Student arver fra Person

Student har en ekstra attribut og metode

greet() findes i Person og kan bruges af Student ## SP10 ### Hvad er white boks test? Hvorn√•r anvender vi white boks test og i hvilke sammenh√¶ng. Hvad er en path test og hvorfor er en 100% path testing stort set altid umulig at gennemf√∏re? Tegn et flowgraph diagram p√• tavlen og forklar hvad en branch test er **Hvad er white-box test?**
</code></pre></div></div>

<p>White-box test (eller strukturtest) er en testmetode, hvor man tester et programs interne struktur og logik. Man kigger ‚Äùind i koden‚Äù og bruger sin viden om, hvordan programmet er bygget.
<strong>Form√•let:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Teste alle logiske grene og kontrolstrukturer

Sikre at alle veje i koden fungerer som forventet

Afsl√∏re fx:

    Ubrugte kodelinjer

    Fejl i loops og betingelser

    Forkert h√•ndtering af kanttilf√¶lde
</code></pre></div></div>

<p><strong>Hvorn√•r bruger man white-box testing ‚Äì og i hvilke sammenh√¶nge?</strong>
Bruges typisk ved	Eksempler<br />
Unit testing	Test af enkeltfunktioner<br />
Integration testing	N√•r moduler integreres og man vil teste flow mellem dem<br />
Ved kritisk kode	F.eks. sikkerhed, beregning, pengeoverf√∏rsel<br />
Automatiseret test	Fx med v√¶rkt√∏jer som JUnit, Pytest, osv.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>White-box testing bruges tidligt i udviklingen af udviklere og QA, og supplerer black-box tests (som kun ser p√• input/output uden at kende koden).
</code></pre></div></div>

<p><strong>Hvad er path testing?</strong></p>

<p>Path testing handler om at teste forskellige stier igennem et program ‚Äì alts√• de mulige k√∏rselsforl√∏b gennem kontrolstrukturen.<br />
Eksempel:</p>

<p>Hvis en funktion har en if-else og et while-loop, kan der v√¶re mange forskellige m√•der, koden kan k√∏res p√• afh√¶ngigt af input.<br />
Hvorfor er 100% path testing n√¶sten umuligt?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Antallet af mulige stier vokser eksponentielt med antal beslutninger

Nogle stier kan v√¶re umulige at n√• pga. logik

Loops med forskellige antal gentagelser giver uendelige kombinationer

Det ville kr√¶ve enormt mange testcases og v√¶re for tidskr√¶vende
</code></pre></div></div>

<p><strong>Hvad er en branch test?</strong></p>

<p>Branch testing er en simplere form for path testing:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Her tester man, at alle grene (branches) i programmet bliver k√∏rt mindst √©n gang

Dvs. hver if, else, case, while, osv. bliver aktiveret i en test
</code></pre></div></div>

<p>Branch testing sikrer, at alle beslutningspunkter i programmet testes.<br />
Tegn et simpelt flowgraph diagram (til tavle):<br />
Kodeeksempel:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def check(value):
    if value &gt; 0:
        print("Positive")
    else:
        print("Non-positive")
</code></pre></div></div>

<p>Flowgraph diagram:</p>

<p>[Start]
      |
     (1)
      |
    [value &gt; 0]
     /     <br />
   (2)     (3)
   |        |
[print P] [print NP]
   \       /
    (4) [Slut]</p>

<p>Forklaring:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1): Start af funktion

(2): Gren for value &gt; 0

(3): Gren for else

(4): Samlet slutpunkt

For branch test skal du have mindst:

    √ât test input hvor value &gt; 0

    √ât test input hvor value &lt;= 0 ### Hvad er debugning? Hvordan bruger man en debugger (princippet)? Hvorn√•r bruger man en debugger? Forklar ud fra et af de tre kodestumper givet p√• moodle, hvordan du vil white boks teste koden. Vis gerne p√• laptop hvis du har den med. **Hvad er debugging?**
</code></pre></div></div>

<p>Debugging er processen, hvor man finder og retter fejl (bugs) i sin kode. Det kan b√•de v√¶re syntaksfejl, logiske fejl, runtime-fejl eller uventet adf√¶rd.
<strong>M√•let:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Forst√• hvor og hvorfor noget g√•r galt

Identificere √•rsagen og ikke kun symptomet

Lave rettelser, s√• koden opf√∏rer sig korrekt
</code></pre></div></div>

<p><strong>Hvordan bruger man en debugger? (princip)</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>En debugger er et v√¶rkt√∏j, der g√∏r det muligt at k√∏re koden trin for trin, observere v√¶rdier og inds√¶tte breakpoints.
Typiske funktioner i en debugger:
Funktion	Beskrivelse
Breakpoint	Pause i koden ‚Äì her stopper eksekveringen
Step over	K√∏rer n√¶ste linje kode, men hopper over funktionkald
Step into	G√•r ind i en funktion og viser dens kode
Step out	Hopper ud af en funktion igen
Watch/Inspect	Se v√¶rdien af variabler live
Call stack	Viser hvilke funktioner, der er kaldt, og i hvilken r√¶kkef√∏lge
Debuggere findes i fx:

VS Code, PyCharm, Eclipse, Xcode

Indbygget i browserens devtools (til JS)

CLI (fx pdb i Python, gdb i C)
</code></pre></div></div>

<p><strong>Hvorn√•r bruger man en debugger?</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Situation	Eksempel
N√•r programmet crasher uden tydelig √•rsag	Segfault, NoneType error
N√•r noget opf√∏rer sig forkert	En funktion returnerer et forkert resultat
N√•r man vil forst√• andres eller egen kompleks kode	Trinvis analyse
Ved white-box testing	N√•r man systematisk tester kontrolstrukturer ## SP11 ### Hvad er en black box test? Forklar princippet bag black box tests. Er det realistisk at risikere at en komplet test skal gennemf√∏re 10^100 kombinationsmuligheder af input v√¶rdier ‚Äì hvorfor/hvorfor ikke? Antag det er, hvordan sikrer du s√• at testen kan gennemf√∏res p√• realistisk kort tid? Argumenter for hvorfor din metode vil v√¶re bullet-proof. Ved sidste sp√∏rgsm√•l, tag gerne udgangspunkt i en l√∏sning fra opgave 1. **Hvad er en Black Box Test?**
</code></pre></div></div>

<p>Black box test (ogs√• kaldet funktionsbaseret test) er en testmetode, hvor du tester systemets funktionalitet udefra ‚Äì alts√• uden at kende den interne kode eller struktur.<br />
<strong>Princippet bag black box testing</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Fokus er p√• input og output: Giver systemet det rigtige output for det givne input?

Tester typisk:

    Funktionalitetskrav

    Brugerinteraktion

    Gr√¶nsev√¶rdier

    Fejlh√•ndtering **Du skriver testcases baseret p√• kravspecifikationen og tester, om programmet opf√∏rer sig som forventet.**     **Er 10^100 kombinationsmuligheder ‚Äì realistisk?**  
</code></pre></div></div>

<p>Nej, det er komplet urealistisk.</p>

<p>Et eksempel:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Forestil dig et system der tager 100 inputfelter, og hvert felt kan have 10 v√¶rdier ‚Üí 1010010100 kombinationer = mere end antallet af atomer i universet.
</code></pre></div></div>

<p><strong>S√•:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Det er umuligt at teste alle kombinationer

Det vil tage uendelig lang tid og regnekraft
</code></pre></div></div>

<p><strong>‚úÖ Hvordan tester vi alligevel p√• realistisk tid?</strong></p>

<p>Ved at bruge strategiske metoder:</p>
<ol>
  <li>
    <p>√Ükvivalensklasser</p>

    <p>Del input i grupper, hvor du forventer samme adf√¶rd</p>

    <p>Test kun √©n v√¶rdi pr. gruppe</p>
  </li>
</ol>

<p>üîß Eksempel: Hvis alder skal v√¶re 18‚Äì100, s√• test:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Undergr√¶nse: 17 (ulovlig)

Gyldig: 25

Overgr√¶nse: 101 (ulovlig)
</code></pre></div></div>

<ol>
  <li>
    <p>Gr√¶nsev√¶rditest (Boundary Value Analysis)</p>

    <p>Fejl sker oftest ved gr√¶nser, fx 0, 1, max</p>

    <p>Test fx v√¶rdier: min-1, min, min+1, max-1, max, max+1</p>
  </li>
  <li>
    <p>Fejlspekulation / Edge cases</p>

    <p>Brug erfaring og viden om typiske fejl</p>

    <p>Eksempler: tom input, null, ekstremt store/sm√• tal</p>
  </li>
  <li>
    <p>Risiko-baseret test</p>

    <p>Priorit√©r test p√• funktioner der er forretningskritiske eller fejl-udsatte</p>
  </li>
</ol>

<p>üõ°Ô∏è Argument: Hvorfor er dette ‚Äúbulletproof‚Äù?</p>

<p>Det er ikke muligt at sikre 100% korrekthed i alle situationer, men:</p>

<p>‚úÖ Disse metoder minimerer risikoen for kritiske fejl
‚úÖ De fokuserer indsatsen p√• de vigtigste og mest fejl-udsatte omr√•der
‚úÖ De g√∏r det muligt at teste hurtigt og effektivt med h√∏j d√¶kning
‚úÖ Kombineret med white-box tests, f√•r du b√•de intern og ekstern testd√¶kning
üß™ Eksempel: BubbleSort fra opgave 1</p>

<p>Krav:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BubbleSort skal sortere listen i stigende orden
</code></pre></div></div>

<p>Black box test cases:
Test Case	Input	Forventet Output
Tom liste	[]	[]
√ân v√¶rdi	[5]	[5]
Allerede sorteret	[1, 2, 3]	[1, 2, 3]
Omvendt sorteret	[3, 2, 1]	[1, 2, 3]
Dobbeltv√¶rdier	[2, 2, 1]	[1, 2, 2]</p>

<p>‚ö†Ô∏è Bem√¶rk: Her kender vi ikke hvordan koden er lavet (black box), men vi ved hvordan den skal opf√∏re sig.</p>
<h3 id="hvis-noget-kode-ser-ud-til-at-virke-er-du-s√•-helt-sikker-hvordan-sikrer-du-dig-at-du-ogs√•-vil-have-den-kode-til-at-v√¶re-ansvarlig-for-n√¶ste-flytur-du-selv-skal-p√•-beskriv-hvordan-du-fandt-fejlen-i-det-kode-der-blev-givet-i-opgave-2-er-du-sikker-p√•-du-fandt-alle-fejl-argumenter-hvorfor-du-er-sikke">Hvis noget kode ser ud til at virke, er du s√• helt sikker? Hvordan sikrer du dig, at du ogs√• vil have den kode til at v√¶re ansvarlig for n√¶ste flytur du selv skal p√•? Beskriv hvordan du fandt fejlen i det kode der blev givet i opgave 2. Er du sikker p√• du fandt ALLE fejl? Argumenter hvorfor du er sikke</h3>
<p><strong>Hvis noget kode ser ud til at virke ‚Äì er man s√• helt sikker?</strong></p>

<p>Nej ‚Äì aldrig.</p>

<p>At koden ser ud til at virke, betyder kun, at den virker i de tilf√¶lde, du har testet den.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Men hvad med alle de utestede situationer, inputkombinationer, kanttilf√¶lde eller fejlscenarier?
</code></pre></div></div>

<p>N√•r det handler om kritiske systemer, som fx en flyver, s√• er ‚Äúdet virker p√• min maskine‚Äù ikke godt nok.
‚úÖ Hvordan sikrer man sig kvalitet og sikkerhed?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Grundig test:

    Brug b√•de black box og white box tests

    Test gr√¶nsetilf√¶lde, fejlscenarier, store input, tomme input, uventede input

Code review:

    Flere √∏jne opdager flere fejl

    Du f√•r feedback p√• b√•de logik og struktur

Statisk analyse:

    Brug v√¶rkt√∏jer der automatisk analyserer koden for potentielle fejl (f.eks. pylint, mypy, flake8)

Formal verification (i kritiske systemer):

    Matematiske beviser for at koden opf√∏rer sig korrekt

Test coverage:

    Hvor meget af koden bliver faktisk ramt af tests? (Fx med coverage.py)
</code></pre></div></div>

<p>üêõ Hvordan fandt vi fejlene i opgave 2?</p>

<p>Vi gennemgik koden linje for linje, og:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Brugte white-box teknik til at se p√• intern logik

Spottede:

    Forkert abs(...) brugt i sammenligning

    Forkert initialisering og opdatering af swapped i bubble sort

    Logiske fejl i rekursiv tilgang ‚Üí risiko for uendelig l√∏kke

    Misforst√•else af sorteringsretning

    Manglende input() validering
</code></pre></div></div>

<p>‚ùìEr vi sikre p√•, at vi har fundet ALLE fejl?</p>

<p>Nej ‚Äì men vi har reduceret risikoen betydeligt.</p>

<p>Vi kan ikke 100% garantere, at der aldrig er fejl. Der kan stadig v√¶re:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Edge cases vi ikke har testet

Performance-problemer p√• store inputs

Fejl ved flydende tal, NaN, inf, etc.
</code></pre></div></div>

<p>Men:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Vi har anvendt systematiske metoder

Vi har lavet grundige test og kontrol

Og vi har lavet logiske forbedringer i strukturen
</code></pre></div></div>

<p>Det g√∏r os trygge ved funktionaliteten, men vi ville stadig ikke bruge det i en flyver uden meget mere test og certificering.
üß† Konklusion</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>At v√¶re professionel udvikler betyder ikke at ‚Äútro‚Äù koden virker ‚Äì det betyder at dokumentere og teste, indtil man ved, at den virker ‚Äî i hvert fald under de definerede krav og foruds√¶tninger.
</code></pre></div></div>

