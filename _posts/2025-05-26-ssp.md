# Del 1: Produktudvikling
## SP1 
### Hvad er det primÃ¦re formÃ¥l med opportunity identification processen og hvad er de vigtigste output? Beskriv/eksemplificer hvordan man kan udfÃ¸re processen.
En del af frontend, der er forkel pÃ¥ vores ide og en opportunity, Ide er en impulse, opportunity er markeds tilpasset.  
En god opportunity skal overkomme en kvalitets barrier.  
Disse opportunities kan komme internt eller eksternt fra.  
Opprtunity horizons.  Hensyn til Computeren  
Horizont 1 = SmÃ¥ forbedringer  
Horizont 2 = nye lÃ¸sninger / teknologier, eller ramme et andet marked, som til bÃ¸rn.  
Horizont 3 = Innovative lÃ¸sninger, Iphone, Homeassistant, Computeren.

Step by step  
Tragt formet, tournament  
**Step 1:** Innovation Charter, / catagori  
Balance mellem katagori stÃ¸rrelse og begÃ¦nsning og overskuelighed.  
**Step 2:** Idea Generation  
UndersÃ¸ge konkurrenter, nye teknologier, snakker med kunder, studerer markedet, find ulemper med nuvÃ¦rende product.  
**Step 3:** Screen Ideas
Fjern urimelige ideer, er dette faktisk muligt.  
**Step 4:** Uddyb gode ideer
UndersÃ¸ge similare produkter, estimere markedet, hvordan kan dette egentligt udfÃ¸res, smÃ¥ prototyber.  
**Step 5:** Select Candidates  
Sammenlign mellem criterier, og kan vi faktisk lave dette.  
**Output**   
Key product features, business goals.  
  
Hvad ved jeg at jeg ikke ved, og hvad ved jeg
### Er det radikalt nye produkter altid det bedste mÃ¥l? Hvad er fordelen og ulempen ved radikalt nye produkter?
Ikke udnyttet marked, dyrer lÃ¸sning / mere udvikling / HÃ¸j risiko, ikke bevidst marked.
## SP2
### Hvad kan vanskeliggÃ¸re indhentningen af customer needs? Hvorfor er indhentningen af disse et sÃ¦rligt vigtigt step i produktudviklingsprocessen?
Det er vigtigt at vide hvad kunderne har brug for, da i sidste ende er det kunderne der bestemmer om produktet skal have success.  
Men det kan vÃ¦re svÃ¦rt da kunder ikke altid ved hvad de vil have, og hvem er dine kunder egentligt  
SÃ¦tter udgangspunkt for kravspecifikationen.  
**4 steps** 
**Step 1**  Gather Raw data  
Intervies, focus grupper, observering a customers(Xbox kinect), Surveys  
Der er forskel pÃ¥ kunder, den gennemsnitlige og elite kunder.    Jeg er elite bruger af min laptop. Pas pÃ¥ elite brugerne.
Brand loyalty.
Interview guide, hvad er miljÃ¸et, go with the flow, hver objektiv, probs.
Man fÃ¥r customer statements  
**Step 2**  Interpret Data   
Det vi gjorde efter at have snakket med christoffer.
Omskrive og fortolke kunde statements til hvad produktet kan.
UndgÃ¥ lÃ¸snings mode. UndgÃ¥ must and should.
Ikke filtrer endnu.  
**Step 3**  Organise Needs   
Grupper statements, og sorter data.
Ikke fjern modsigende statements endnu.  
**Step4**  Prioritise Needs  
Prioriter pÃ¥ baggrund af hvor mange gange det er blevet sagt.
### Hvilke andre interessenter kunne vÃ¦re relevante at indhente krav til produktet fra? Hvordan vil du gÃ¸re det?
Konkurrenter(Hvad kan konkurrenterne), desk study,  Lego, kunden er forÃ¦ldre, barn er bruger.
Butikker og resellers, Hvad mener vi selv mangler intern
## SP3
### Hvilke typer af modularitet findes der for en modulÃ¦r produktarkitektur? Giv et par eksempler fra konkrete produkter.
Platform modularitet.  Noget produkter deler kan udvikles for sig selv. F.eks VW elbil platform, sÃ¥ batterierne er ens. AMD's Chiplets, som bruges i alle produkter, fra bÃ¦rbar til server.
Fuldt modulÃ¦r.
Semi modulÃ¦r (smartphones er godt eksempel)
Integral. Helt integreret.  
**Slot-Modular** (Smarphone) Ting kan connect 1 sted pÃ¥ det samlede produkt.  
**Bus-Modular** (server/desktop er lidt begge) Alt forbindes til et samlet punkt / ens interface.  
**Sectional-Modular** (Google tingen) Alle moduler er independent, Lego, ting kan stables.  

    
### Er en modulÃ¦r produktarkitektur altid en fordel? Er det tilfÃ¦lde hvor en integreret arkitektur er en fordel? Giv gerne eksempler.
integreret architecture kan give et "bedre" ende produkt, men kan komme med udviklings udfordringer.
Men samtidigt kan modulÃ¦r arkitektur gÃ¸re alle delene extra specialle da alle ikke behÃ¸ver et overblik over hele lÃ¸sningen.
Mindre produkter. ModulÃ¦r giver et formt for overhead, ligesom Object orienteret ogsÃ¥ kan gÃ¸re.
eksempel (Ram slots er modulÃ¦re, men har hÃ¸jere latens og laver clock speeds).
Fordel er at man kan nemt customize til bestemt cusomer.
## SP4
### I kurset har vi anvendt en â€screening & scoringâ€ matrix til at udvÃ¦lge et endeligt koncept. Hvad er styrken ved denne metode? Hvad kunne alternative metoder vÃ¦re til at vÃ¦lge et koncept?
Et godt koncept men dÃ¥rligt udfÃ¸rt kan vÃ¦re sucess, men dÃ¥rligt koncept er altid dÃ¥rligt.  
Del produktet op i funktioner / behov(Bilen interrior behÃ¸ves ikke at hÃ¦nge sammen med motoren).  
Blackbox, Input & output, og hvad sker der sÃ¥ i denne kasse?.  
Hvordan bliver dette i kassen sÃ¥ gjort, teknisk specifikt. UndersÃ¸g eksiterende lÃ¸sninger, snak med experter, undersÃ¸g specifikke technologier.  
UndersÃ¸g internt, technologisk, og brug de egenskaber gruppe medlemmerne har.  
Disse koncepter kan sÃ¥ blive valgt ved screening & scoring.  
steps = Prepare matrix - Rate - Rank - Combine(Merge nogle gode ting man opdager undervejs) - Select:  
Tag udgangpunkt i 1 koncept, sÃ¦t til lig 0, og sammenlign anre koncepter i forhold til dette.  
Nu kan vi vÃ¦gte vÃ¦rdierne, og derfor prioritere.  
Scoring og vÃ¦gtning kan hurtigt vÃ¦gte ting mod preferrencer.   
Det er vigtigt at have tÃ¦nkt over vÃ¦gtende, og ikke Ã¦ndre vÃ¦gtende for at prioritere andet produkt.  
KrÃ¦ver en god analyse af features, og krav.  
PÃ¥ dette tidpunkt kan det vÃ¦re svÃ¦rt at vurdere hvad man bÃ¸r scorer de forskellige koncepter.  
Alternativ, Vi begyndte at arbejde pÃ¥ forskellige ting samtidigt, og lÃ¸bende estimere lÃ¸sninger.  
### Hvad kunne du gÃ¸re for at Ã¸ge trovÃ¦rdigheden af de enkelte scorer i matrixen?
UnderstÃ¸tte dem med kilder og argumentationer, eller basere dem pÃ¥ customer needs undersÃ¸gelser.  
FÃ¥ kunder til at score koncepterne, og give deres mening pÃ¥ det.
## SP5
### Hvad er fordelene ved at fÃ¸lge en struktureret metode til produktudvikling? Hvad risikerer man ved ikke at gÃ¸re det?
Man risikerer at man ender ud med et produkt der ikke lever op til kravene, eller ikke har nogle kunder.  
mere...
SP5 â€“ Struktur i produktudvikling
Hvad er fordelene ved at fÃ¸lge en struktureret metode til produktudvikling? Hvad risikerer man ved ikke at gÃ¸re det?

Fordele:

    MÃ¥lrettethed og fokus â€“ En struktureret metode sikrer, at man arbejder mod klart definerede mÃ¥l, sÃ¥som kundebehov, tekniske krav og forretningsmÃ¥l.

    Tids- og ressourceeffektivitet â€“ Ved at fÃ¸lge faser som behovsanalyse, konceptudvikling, prototype og test undgÃ¥r man spildarbejde.

    Bedre kommunikation i teamet â€“ Struktur giver et fÃ¦lles sprog og forventningsafstemning i tvÃ¦rfaglige teams.

    Dokumentation og lÃ¦ring â€“ Man skaber sporbarhed og mulighed for evaluering og forbedring til fremtidige projekter.

    Kundecentrering â€“ En god metode (f.eks. Stage-Gate, V-model eller Ulrich & Eppinger) inkluderer kundebehov i processen, hvilket Ã¸ger chancen for succes pÃ¥ markedet.

Risici ved ikke at fÃ¸lge en struktureret metode:

    Udvikling af et produkt uden marked (ingen efterspÃ¸rgsel).

    Fejl og omarbejdning pga. manglende kravspecifikationer.

    Manglende integration mellem delsystemer.

    Uklare roller og ansvar â†’ dÃ¥rlig teamkoordinering.

    Projektet lÃ¸ber lÃ¸bsk i tid og budget.
### Hvad er nogle af de stÃ¸rste faldgrupper som produktudviklingsteam i forbindelse med processen?
Tech-demoer i stedet for rigtige produkter
    â€“ Fokus pÃ¥ teknologi frem for brugerbehov. Det kan fÃ¸re til, at man laver noget "smart", som ingen har brug for.

    Springe behovsanalysen over
    â€“ Mange teams gÃ¥r direkte til lÃ¸sning, uden at forstÃ¥ kundens egentlige problemer. Det fÃ¸rer ofte til forkerte lÃ¸sninger.

    DÃ¥rlig kravspecifikation
    â€“ Uklare eller ikke-prioriterede krav giver konflikt senere i projektet, isÃ¦r ved test og implementering.

    Ingen iterativ test og feedback
    â€“ Man udvikler hele produktet uden at teste det lÃ¸bende. SÃ¥ opdager man fejlene for sent og mÃ¥ redesigne.

    Manglende involvering af relevante interessenter
    â€“ Hvis marketing, produktion eller kunder ikke inddrages, kan man ende med et produkt der er svÃ¦rt at sÃ¦lge eller producere.

    For lidt dokumentation
    â€“ Uden tilstrÃ¦kkelig dokumentation kan man ikke overlevere viden, og fremtidig vedligehold bliver svÃ¦r.

    Scope creep
    â€“ Projektets mÃ¥l udvides hele tiden uden kontrol, sÃ¥ man mister fokus og overskrider budget og tid.

# Del 2: Kravsspecifikation og system design.
## SP6
### Hvad er et use case diagram? Hvilke elementer bestÃ¥r det af? Hvad bruger man det til? HvornÃ¥r anvender man use case diagrammer? Tegn eller vis eksempel/eksempler.
Hvad er et use case diagram?

Et use case-diagram viser aktÃ¸rer (brugere eller andre systemer) og deres interaktioner (use cases) med systemet. Det beskriver funktionerne (use cases), som systemet skal levere, og hvordan brugerne interagerer med dem.  
**Hvilke elementer bestÃ¥r det af?**

    System (grÃ¦nse) â€“ Angivet som en rektangulÃ¦r boks, der indeholder use cases. Det er dÃ©t system, man beskriver.

    Use case (brugssituation) â€“ En oval der beskriver en funktion (f.eks. "Log ind", "Bestil produkt").

    AktÃ¸r (actor) â€“ En stick-figur, der reprÃ¦senterer en bruger eller andet system, der interagerer med systemet.

**Relationer:**  

    Association (linje): Forbindelse mellem aktÃ¸r og use case.

    Include: Angiver at en use case altid inkluderer en anden.

    Extend: Angiver at en use case nogle gange udvides med en anden, fx afhÃ¦ngigt af betingelser.

**Hvad bruger man det til?**

    FÃ¥ overblik over funktionelle krav til et system.

    Kommunikere med interessenter (brugere, kunder, udviklere).

    Dokumentere brugerbehov og systemets forventede opfÃ¸rsel.

    Analyse og design af software og interaktionsflow.

**HvornÃ¥r anvender man use case-diagrammer?**

    Tidligt i kravspecifikationsfasen i systemudvikling.

    Under analyse og design.

    NÃ¥r man vil visualisere brugerinteraktioner og sikre, at alle funktioner er dÃ¦kket.

    Som supplement til user stories og funktionelle krav
### Hvad er en use case beskrivelse? Hvad er vigtigt i en sÃ¥dan beskrivelse? Hvordan relaterer disse sig til krav specifikationerne? HvornÃ¥r udarbejder man beskrivelserne? Hvem udarbejder dem? Giv eksempler.
**Hvad er en use case-beskrivelse?**

En use case-beskrivelse er en tekstuel (detaljeret) beskrivelse af, hvordan en aktÃ¸r interagerer med systemet for at opnÃ¥ et bestemt mÃ¥l. Hvor use case-diagrammer viser overblik, gÃ¥r beskrivelsen i dybden med trin-for-trin scenarier.
**Hvad er vigtigt i en use case-beskrivelse?**  

    En god use case-beskrivelse indeholder typisk fÃ¸lgende elementer:  
    Felt	Beskrivelse  
    Navn	Kort og prÃ¦cis titel (f.eks. "Log ind")  
    MÃ¥l	Hvad aktÃ¸ren Ã¸nsker at opnÃ¥  
    PrimÃ¦r aktÃ¸r	Den bruger eller system der initierer use casen  
    Interessenter og behov	Hvem har interesse i funktionen og hvorfor  
    ForudsÃ¦tninger	Hvad skal vÃ¦re opfyldt fÃ¸r handlingen starter  
    EfterfÃ¸lgende tilstand	Hvad er opnÃ¥et, hvis use casen lykkes  
    HovedforlÃ¸b (normal flow)	De vigtigste trin i interaktionen  
    Alternative forlÃ¸b / Undtagelser	Hvad sker der, hvis noget gÃ¥r galt eller afviger  
    Frekvens (valgfrit)	Hvor ofte use casen typisk forekommer  
**Hvordan relaterer use case-beskrivelser sig til kravspecifikationer?**

    Use case-beskrivelser konkretiserer funktionelle krav fra kravspecifikationen.

    De fungerer som en slags bro mellem overordnede krav og teknisk design.

    GÃ¸r det nemt at teste og verificere, om krav er opfyldt (basis for test cases).

    HjÃ¦lper med at prioritere funktionalitet baseret pÃ¥ brugerens behov.

**HvornÃ¥r og af hvem udarbejdes de?**

    SpÃ¸rgsmÃ¥l	Svar
    HvornÃ¥r?	I krav- og analysefasen â€“ gerne fÃ¸r design og kodning starter.
    Hvem?	Typisk systemanalytikere, UX-designere, eller produktudviklere â€“ ofte i samarbejde med kunden eller slutbrugere.
    âœï¸ Eksempel pÃ¥ use case-beskrivelse

**Use case: Bestil produkt**

    MÃ¥l: Kunden Ã¸nsker at bestille et produkt online.

    PrimÃ¦r aktÃ¸r: Kunde

    Interessenter: Kunden (hurtig levering), webshop (salg), lager (ordrebehandling)

    ForudsÃ¦tning: Kunden er logget ind og har fundet et produkt.

    EfterfÃ¸lgende tilstand: Ordren er registreret og bekrÃ¦ftet.

HovedforlÃ¸b:

    Kunden klikker pÃ¥ "KÃ¸b" pÃ¥ produktet.

    Systemet viser kurven og totalbelÃ¸b.

    Kunden klikker pÃ¥ "GÃ¥ til betaling".

    Kunden indtaster leverings- og betalingsoplysninger.

    Kunden klikker "BekrÃ¦ft".

    Systemet validerer oplysningerne og opretter ordren.

    Kunden fÃ¥r bekrÃ¦ftelse pÃ¥ ordren.

Alternative forlÃ¸b:

    4a. Kunden vÃ¦lger at betale med MobilePay.

    6a. Hvis betaling mislykkes â†’ system viser fejl og beder om ny metode.
## SP7
### Hvad karakteriserer gode krav? Giv eksempler pÃ¥ gode og dÃ¥rlige krav. Hvor i V-modellen finder vi hvilke typer af krav? Med hvem udarbejder vi krav og pÃ¥ hvilke mÃ¥de sikrer vi at vi fÃ¥r samtlige vigtige krav med i kravspecifikationen?
**Hvad karakteriserer gode krav?**

**Gode krav skal vÃ¦re:**

    Kvalitet	Forklaring
    Entydige	Kravet skal kun kunne forstÃ¥s pÃ¥ Ã©n mÃ¥de (ingen tvetydighed).
    Testbare / Verificerbare	Det skal vÃ¦re muligt at afprÃ¸ve, om kravet er opfyldt.
    NÃ¸dvendige	Kun krav, der har reel vÃ¦rdi for systemet eller brugeren.
    Tydelige og prÃ¦cise	Ikke vage begreber som "hurtig", "let" eller "bedre".
    Sporbare	Man skal kunne se, hvor kravet stammer fra (f.eks. en kundeanmodning).
    Konsistente	Krav mÃ¥ ikke modsige hinanden.

**Eksempler pÃ¥ gode og dÃ¥rlige krav**

    DÃ¥rligt krav	Hvorfor dÃ¥rligt	Godt krav (forbedret)
    "Systemet skal vÃ¦re hurtigt."	Uklart, subjektivt	"Systemet skal svare inden for 1 sekund i 95â€¯% af alle tilfÃ¦lde."
    "Brugeren skal nemt kunne oprette en profil."	Ikke mÃ¥lbart	"Brugeren skal kunne oprette en profil via en formular med maks. 5 felter."
    "Appen skal vÃ¦re moderne."	For vag og uprÃ¦cis	"Appen skal fÃ¸lge Android Material Design 3 retningslinjer."

**Hvor i V-modellen findes kravene?**

V-modellen beskriver systemudvikling som en proces, hvor hver fase pÃ¥ venstresiden har en tilsvarende testfase pÃ¥ hÃ¸jresiden. Krav findes pÃ¥ venstresiden i starten af udviklingen:
Fase i V-modellen	Type krav
Brugerbehov (toppen)	Overordnede forretnings- og brugerkrav
Systemkrav	Funktionelle og ikke-funktionelle krav
Designkrav	Tekniske specifikationer for hvordan kravene opfyldes

PÃ¥ hÃ¸jresiden verificeres kravene gennem test: systemtest, integrationstest, enhedstest â€“ baseret direkte pÃ¥ kravene.
**Med hvem udarbejder vi krav?**

Krav udarbejdes i samarbejde med:

    Slutbrugere / kunder â€“ deres behov og Ã¸nsker er fundamentale.

    Forretningsanalytikere / produktledere â€“ oversÃ¦tter behov til krav.

    Udviklere / arkitekter â€“ vurderer realiserbarhed.

    Testere â€“ sikrer at krav kan testes.

    UX-designere â€“ bidrager til brugervenlighedskrav.

Hvordan sikrer vi, at vi fÃ¥r alle vigtige krav med?

    Workshops & interviews med interessenter.

    Observationer & kontekstuel analyse â€“ se hvordan nuvÃ¦rende systemer bruges.

    Brainstorming og kravindsamlingsteknikker (f.eks. MoSCoW, Kano).

    Use cases og user stories â€“ hjÃ¦lper med at identificere funktionelle krav.

    Prototyper og mockups â€“ skaber feedback og afdÃ¦kker oversete krav.

    Sporbarhedsmatrix â€“ kobler krav til test, design og forretningsmÃ¥l.
### Hvilke krav har vi til vores kravspecifikation? Hvordan sikrer vi at krav til krav er opfyldt? Hvordan bruger vi krav i efterfÃ¸lgende udviklingsproces? Hvordan forholder vi os til at skulle lave Ã¦ndringer i krav i de efterfÃ¸lgende tidsperioder i en udviklingsproces f.eks. hen mod slutningen af projektet? Giv eksempler.
Hvilke krav har vi til vores kravspecifikation?

**En kravspecifikation skal vÃ¦re:**

    Krav til kravspecifikationen	Beskrivelse
    Komplet	Alle relevante funktionelle og ikke-funktionelle krav skal vÃ¦re med.
    Entydig	Hvert krav skal kun kunne forstÃ¥s pÃ¥ Ã©n mÃ¥de.
    Testbar	Det skal vÃ¦re muligt at verificere hvert krav.
    Sporbar	Hvert krav skal kunne spores til kilder (behov, interessenter) og til test, design og kode.
    Struktureret og prioriteret	Kravene skal vÃ¦re velorganiserede og eventuelt prioriteret (f.eks. MoSCoW: Must, Should, Could, Wonâ€™t).
    Versionsstyret	Man skal kunne fÃ¸lge Ã¦ndringer over tid (hvem Ã¦ndrede hvad og hvornÃ¥r).
**Hvordan sikrer vi, at â€œkrav til kravâ€ er opfyldt?**

    Review og godkendelse
    â€“ GennemgÃ¥ kravene med interessenter og fÃ¥ dem godkendt. Brug evt. checklister (f.eks. IEEE-830).

    Sporbarhedsmatrix
    â€“ KortlÃ¦g alle krav til relaterede designbeslutninger og testcases.

    Brug af skabeloner og vÃ¦rktÃ¸jer
    â€“ KravspecificeringsvÃ¦rktÃ¸jer (f.eks. Jira, IBM DOORS) hjÃ¦lper med konsistens, dokumentation og versionsstyring.

    Testbarhedsanalyse
    â€“ InvolvÃ©r testere tidligt: â€œKan dette krav testes?â€ Hvis ikke, skal det omskrives.

    Roller og ansvar
    â€“ Tydelige ejere af kravene sikrer ansvar for indhold og Ã¦ndringer.

**Hvordan bruger vi krav i den efterfÃ¸lgende udviklingsproces?**

    Kravene er fundamentet for hele udviklingsprocessen:
    Procesfase	Brug af krav
    Design	Udviklere og arkitekter bruger krav til at beslutte systemets struktur og komponenter.
    Implementering	Kode baseres pÃ¥ funktionelle krav.
    Test	Testcases laves ud fra krav (accepttest, systemtest).
    Verifikation og validering	Bruges til at afgÃ¸re, om det udviklede system matcher krav og behov.
    Dokumentation og overlevering	Krav dokumenterer, hvad systemet skal kunne â€“ bruges til support og videreudvikling.
**Hvordan hÃ¥ndterer vi Ã¦ndringer i krav sent i udviklingsforlÃ¸bet?**

Ã†ndringer sker ofte â€“ men sent i processen er de dyrere og risikofyldte.
SÃ¥dan hÃ¥ndteres det:

    Change Request-proces
    â€“ Formaliseret mÃ¥de at foreslÃ¥, evaluere og godkende Ã¦ndringer.

    Impact analysis
    â€“ Hvad pÃ¥virker Ã¦ndringen? Tid, test, funktionalitet, afhÃ¦ngigheder? Dette vurderes fÃ¸r godkendelse.

    Sporbarhed
    â€“ Man kan hurtigt identificere, hvilke komponenter og testcases der berÃ¸res.

    Kommunikation
    â€“ InformÃ©r hele teamet om Ã¦ndringer (dev, test, design, kunde).

    Agile eller iterativ udvikling
    â€“ Hvis muligt: arbejd i iterationer, sÃ¥ krav kan justeres lÃ¸bende med mindre risiko.

**Eksempler pÃ¥ Ã¦ndringer i krav og deres konsekvenser**  
Ã†ndring i krav	Konsekvens	HÃ¥ndtering
"Brugeren skal kunne betale med MobilePay" tilfÃ¸jes sent	Integration med ny betalingsgateway â†’ ekstra udvikling og test	Change request, teknisk vurdering, planjustering  
Ã†ndring af svartid fra 2 sek til 0.5 sek	KrÃ¦ver optimering af backend og database	Reprioritering af performancefokus, evt. delvis opfyldelse  
Krav om at systemet skal virke offline	Ã†ndrer hele arkitekturen	Overvej version 2, lav business case for vÃ¦rdi/kost  
## SP8
### Hvordan deler man effektivt krav op i funktionelle moduler? Hvad definerer et modul? Hvad kan vi bruge modulariseringen til? Giv eksempler, gerne pÃ¥ tavle.
**Hvordan deler man krav op i funktionelle moduler?**  
**GrundidÃ©:**

Du opdeler systemet i mindre funktionelle enheder (moduler), som hver isÃ¦r dÃ¦kker Ã©t specifikt omrÃ¥de af funktionaliteten.
**Metode:**

    IdentificÃ©r hovedfunktioner / use cases
    â€“ Hvad skal systemet kunne?

    GruppÃ©r relaterede krav
    â€“ Krav, der hÃ¸rer sammen funktionelt, samles.

    Opdel efter ansvar og grÃ¦nseflader
    â€“ Hvert modul skal have et klart ansvar og minimalt overlap.

    Overvej brugerroller og systemaktÃ¸rer
    â€“ Hvad har forskellige brugere brug for at gÃ¸re? Dette guider opdelingen.

**Hvad definerer et modul?**

    Et modul er:
    Egenskab	Forklaring
    AfgrÃ¦nset funktionelt omrÃ¥de	LÃ¸ser Ã©n tydelig opgave (f.eks. "BrugerhÃ¥ndtering")
    Indeholder relaterede krav og funktioner	F.eks. "Login", "Opret bruger", "Nulstil adgangskode"
    Har en veldefineret grÃ¦nseflade (API eller UI)	Moduler kommunikerer gennem veldefinerede kald eller skÃ¦rme
    Kan udvikles og testes uafhÃ¦ngigt	GÃ¸r teams mere effektive og reducerer kompleksitet

**Hvad kan vi bruge modularisering til?**
Fordel	Beskrivelse  
âœ… Overblik	Krav bliver lettere at forstÃ¥ og styre  
âœ… Genbrug	Moduler kan genbruges i andre projekter  
âœ… Parallelt arbejde	Teams kan arbejde pÃ¥ forskellige moduler samtidigt  
âœ… Fejlisolering	Fejl lokaliseres hurtigere  
âœ… Ã†ndringer bliver lettere	Ã†ndringer i Ã©t modul pÃ¥virker ikke hele systemet  
âœ… Skalerbarhed	Systemet kan lettere vokse med nye funktioner  
### Hvad er en grÃ¦nseflade? Hvordan bliver man enig om en grÃ¦nseflade? Hvem er involveret i at definere grÃ¦nseflader? Hvilke fordele/ulemper er der ved at definere grÃ¦nseflader tidligt/sent i et projektforlÃ¸b? Giv eksempler

**Typer af grÃ¦nseflader:** 

    Type	Eksempel
    Teknisk grÃ¦nseflade	API mellem backend og frontend
    Fysisk grÃ¦nseflade	Stikforbindelse, skÃ¦rm, knap
    BrugergrÃ¦nseflade (UI)	App-skÃ¦rmbilleder, menuer, formularer
    ProcesgrÃ¦nseflade	Overlevering mellem to teams eller systemer i et workflow
**Hvordan bliver man enig om en grÃ¦nseflade?**

    IdentificÃ©r behov og afhÃ¦ngigheder
    â€“ Hvad har de to parter brug for fra hinanden?

    Samarbejde og kommunikation
    â€“ Design, software, hardware, test og brugerreprÃ¦sentanter skal involveres.

    Brug specifikationer og diagrammer
    â€“ Brug f.eks.:

        Interface-specifikationer (API-dokumenter, wireframes)

        Sekvensdiagrammer, I/O-skemaer

    Prototyper og mockups
    â€“ Visualisering af interaktion hjÃ¦lper parterne med at forstÃ¥ grÃ¦nsefladen.

**Hvem er involveret i at definere grÃ¦nseflader?**

    Rolle	Bidrag
    Systemarkitekt	FastlÃ¦gger overordnede tekniske grÃ¦nseflader
    Softwareudviklere	Definerer f.eks. APIâ€™er mellem komponenter
    Hardwareudviklere	Ved fysiske grÃ¦nseflader (sensorer, knapper, porte)
    UX-designere	Ved brugergrÃ¦nseflader (UI)
    Testere	Sikrer at grÃ¦nsefladen kan testes og valideres
    Kunder/brugere	Ved brugerinteraktion eller systemintegration
    â±ï¸ Fordele og ulemper ved tidlig/sen definition
    Timing	Fordele	Ulemper
    Tidlig	- GÃ¸r parallel udvikling muligt
    - Giver klar struktur
    - Giver testmuligheder tidligere	- Risiko for Ã¦ndringer senere
    - Kan lÃ¥se fast i et forkert design
    Sen	- Mere viden og erfaring
    - Bedre tilpasning til reelle behov	- Forsinker udvikling
    - Skaber afhÃ¦ngigheder og flaskehalse
    - Ã˜get risiko for misforstÃ¥elser
**Eksempler**
**Teknisk eksempel (software):**

    Et API mellem en webshop-frontend og backend:

        GrÃ¦nsefladen definerer kald som: GET /products, POST /checkout

        Frontend- og backendteams arbejder parallelt, fordi grÃ¦nsefladen er defineret tidligt

**Fysisk eksempel (produktdesign):**

    En elektrisk motor med en standardiseret stikforbindelse til styring:

        GrÃ¦nsefladen er stiktypen + datasignaler

        Motor og styringsmodul kan udvikles hver for sig

**BrugergrÃ¦nseflade:**

    En app har et loginmodul, som leverer brugerinfo til resten af systemet

        UI og backend skal blive enige om: Hvilke felter vises? Hvad sendes?


# Del 3: Implementering og test
## SP9
### Hvad er kodestil og kodestruktur? For hvem er dette vigtigt? Hvad har I gjort i jeres projekt? Hvordan bliver man enige om f.eks. brug af white space eller tabâ€™s? Giv eksempler pÃ¥ forskellige kodestilarter der kan Ã¸ge lÃ¦sevenligheden, og eksempler pÃ¥ det modsatte (der mindsker lÃ¦sevenligheden).
**Hvad er kodestil og kodestruktur?**
**Kodestil**

Kodestil handler om hvordan koden ser ud â€“ det visuelle og sproglige udtryk. Det dÃ¦kker fx:

    Brug af indrykning (tabs vs. spaces)

    Navngivning af variabler og funktioner (camelCase, snake_case)

    Brug af mellemrum og linjeskift

    Kommentarstil og placering

    Placering af {} i funktioner og kontrolstrukturer

Eksempel pÃ¥ to forskellige kodestile i JavaScript:

    // Kodestil 1 (kompakt, men lidt svÃ¦rere at lÃ¦se)
    function add(a,b){return a+b;}

    // Kodestil 2 (mere lÃ¦sbar)
    function add(a, b) {
      return a + b;
    }

**Kodestruktur**

Kodestruktur handler om hvordan koden er organiseret logisk:

    Filstruktur (mappestruktur)

    Moduler og komponenter

    Funktionsopdeling (smÃ¥, genanvendelige funktioner)

    Separation of concerns (logik adskilt fra prÃ¦sentation og data)

Eksempel:

    projekt/
    â”œâ”€â”€ controllers/
    â”‚   â””â”€â”€ userController.js
    â”œâ”€â”€ models/
    â”‚   â””â”€â”€ userModel.js
    â”œâ”€â”€ routes/
    â”‚   â””â”€â”€ userRoutes.js
    â””â”€â”€ app.js

**For hvem er dette vigtigt?**

    For hele teamet: Giver fÃ¦lles sprog og fÃ¦rre misforstÃ¥elser.

    For fremtidige udviklere: Koden bliver nemmere at vedligeholde.

    For review og samarbejde: GÃ¸r kodegennemgang hurtigere og mere effektiv.

    For test og debugging: En ensartet stil gÃ¸r det nemmere at finde fejl.

ðŸ’¬ Hvordan bliver man enige om stil (fx tabs vs. spaces)?

    LÃ¦g fÃ¦lles retningslinjer fra starten:

        Brug fx Google Style Guide, Airbnb JS Guide, PEP8 (Python) osv.

    AutomatisÃ©r med linters og formateringsvÃ¦rktÃ¸jer:

        Eksempler: ESLint, Prettier, Black (Python), clang-format

    Lav en README.md eller CONTRIBUTING.md med stilregler

    Brug Git pre-commit hooks til at tjekke stil fÃ¸r kode pushes

âœ… Eksempler pÃ¥ god kodestil (lÃ¦sevenlig)

    def calculate_total(price, tax_rate):
        """Calculate total price including tax."""
        return price * (1 + tax_rate)

    Klar funktion

    Gode navne

    Kommentar (docstring)

    Lige mellemrum

âŒ Eksempler pÃ¥ dÃ¥rlig kodestil (ulÃ¦selig)

    def ct(p,t):return p*(1+t)

    DÃ¥rlige navne

    Ingen mellemrum

    Ingen kommentar

    Alt pÃ¥ Ã©n linje
kamelCase, navngivning, function stÃ¸rrelse, nasa's krav.
Vi havde bÃ¥de python og C++, python blev tjekket via github action, c++ var mere skrevet sÃ¥ det man skrev lignede det der allerede stod. Manglede generelt mÃ¥ske lidt konsistens.
### Hvad er objekt orienteret programmering? Hvad er en klasse i forhold til et objekt? Hvad er et klassediagram? Tegn gerne et simpelt et pÃ¥ tavlen og diskuter ud fra det tegnede diagram.
**Hvad er objektorienteret programmering (OOP)?**

Objektorienteret programmering er en programmeringsparadigme, hvor man strukturerer kode omkring objekter, som reprÃ¦senterer ting, begreber eller enheder i virkeligheden.
**NÃ¸gleprincipper i OOP:**

    Princip	Forklaring
    Indkapsling	Data og funktioner gemmes sammen i objekter
    Arv	En klasse kan arve egenskaber fra en anden
    Polymorfi	Objekter kan opfÃ¸re sig forskelligt, selvom de deler samme interface
    Abstraktion	Skjuler kompleksitet og viser kun nÃ¸dvendig information
**Hvad er en klasse og et objekt?**
    Begreb	Forklaring
    Klasse	En skabelon eller blueprint for at lave objekter
    Objekt	En konkret instans af en klasse med sine egne data

Eksempel i Python:

    class Dog:               # Klasse
        def __init__(self, name):
            self.name = name

        def bark(self):
            print(f"{self.name} says woof!")

    my_dog = Dog("Fido")     # Objekt (instans af klassen)
    my_dog.bark()            # Output: Fido says woof!

**Hvad er et klassediagram?**

Et klassediagram er en grafisk mÃ¥de at vise klasser og deres relationer pÃ¥. Det er en del af UML (Unified Modeling Language) og bruges i designfasen.
Klassediagrammet viser:

    Klasser

    Attributter (datafelter)

    Metoder (funktioner)

    Relationer mellem klasser (arv, association, komposition osv.)

Tegn et simpelt klassediagram pÃ¥ tavlen
Eksempel: Et system med Person og Student

+--------------+
|   Person     |
+--------------+
| - name       |
| - age        |
+--------------+
| + greet()    |
+--------------+
       â–²
       |
   inherits
       |
+--------------+
|   Student    |
+--------------+
| - studentID  |
+--------------+
| + study()    |
+--------------+

Forklaring:

    Person er en superklasse

    Student arver fra Person

    Student har en ekstra attribut og metode

    greet() findes i Person og kan bruges af Student
## SP10
### Hvad er white boks test? HvornÃ¥r anvender vi white boks test og i hvilke sammenhÃ¦ng. Hvad er en path test og hvorfor er en 100% path testing stort set altid umulig at gennemfÃ¸re? Tegn et flowgraph diagram pÃ¥ tavlen og forklar hvad en branch test er
**Hvad er white-box test?**

White-box test (eller strukturtest) er en testmetode, hvor man tester et programs interne struktur og logik. Man kigger â€ind i kodenâ€ og bruger sin viden om, hvordan programmet er bygget.
**FormÃ¥let:**

    Teste alle logiske grene og kontrolstrukturer

    Sikre at alle veje i koden fungerer som forventet

    AfslÃ¸re fx:

        Ubrugte kodelinjer

        Fejl i loops og betingelser

        Forkert hÃ¥ndtering af kanttilfÃ¦lde

**HvornÃ¥r bruger man white-box testing â€“ og i hvilke sammenhÃ¦nge?**
Bruges typisk ved	Eksempler  
Unit testing	Test af enkeltfunktioner  
Integration testing	NÃ¥r moduler integreres og man vil teste flow mellem dem  
Ved kritisk kode	F.eks. sikkerhed, beregning, pengeoverfÃ¸rsel  
Automatiseret test	Fx med vÃ¦rktÃ¸jer som JUnit, Pytest, osv.  

    White-box testing bruges tidligt i udviklingen af udviklere og QA, og supplerer black-box tests (som kun ser pÃ¥ input/output uden at kende koden).

**Hvad er path testing?**

Path testing handler om at teste forskellige stier igennem et program â€“ altsÃ¥ de mulige kÃ¸rselsforlÃ¸b gennem kontrolstrukturen.  
Eksempel:  

Hvis en funktion har en if-else og et while-loop, kan der vÃ¦re mange forskellige mÃ¥der, koden kan kÃ¸res pÃ¥ afhÃ¦ngigt af input.  
Hvorfor er 100% path testing nÃ¦sten umuligt?  

    Antallet af mulige stier vokser eksponentielt med antal beslutninger

    Nogle stier kan vÃ¦re umulige at nÃ¥ pga. logik

    Loops med forskellige antal gentagelser giver uendelige kombinationer

    Det ville krÃ¦ve enormt mange testcases og vÃ¦re for tidskrÃ¦vende

**Hvad er en branch test?**

Branch testing er en simplere form for path testing:

    Her tester man, at alle grene (branches) i programmet bliver kÃ¸rt mindst Ã©n gang

    Dvs. hver if, else, case, while, osv. bliver aktiveret i en test

Branch testing sikrer, at alle beslutningspunkter i programmet testes.  
Tegn et simpelt flowgraph diagram (til tavle):  
Kodeeksempel:  

    def check(value):
        if value > 0:
            print("Positive")
        else:
            print("Non-positive")

Flowgraph diagram:

   [Start]
      |
     (1)
      |
    [value > 0]
     /     \
   (2)     (3)
   |        |
[print P] [print NP]
   \       /
    (4) [Slut]

Forklaring:

    (1): Start af funktion

    (2): Gren for value > 0

    (3): Gren for else

    (4): Samlet slutpunkt

    For branch test skal du have mindst:

        Ã‰t test input hvor value > 0

        Ã‰t test input hvor value <= 0
### Hvad er debugning? Hvordan bruger man en debugger (princippet)? HvornÃ¥r bruger man en debugger? Forklar ud fra et af de tre kodestumper givet pÃ¥ moodle, hvordan du vil white boks teste koden. Vis gerne pÃ¥ laptop hvis du har den med.
**Hvad er debugging?**

Debugging er processen, hvor man finder og retter fejl (bugs) i sin kode. Det kan bÃ¥de vÃ¦re syntaksfejl, logiske fejl, runtime-fejl eller uventet adfÃ¦rd.
**MÃ¥let:**

    ForstÃ¥ hvor og hvorfor noget gÃ¥r galt

    Identificere Ã¥rsagen og ikke kun symptomet

    Lave rettelser, sÃ¥ koden opfÃ¸rer sig korrekt

**Hvordan bruger man en debugger? (princip)**

    En debugger er et vÃ¦rktÃ¸j, der gÃ¸r det muligt at kÃ¸re koden trin for trin, observere vÃ¦rdier og indsÃ¦tte breakpoints.
    Typiske funktioner i en debugger:
    Funktion	Beskrivelse
    Breakpoint	Pause i koden â€“ her stopper eksekveringen
    Step over	KÃ¸rer nÃ¦ste linje kode, men hopper over funktionkald
    Step into	GÃ¥r ind i en funktion og viser dens kode
    Step out	Hopper ud af en funktion igen
    Watch/Inspect	Se vÃ¦rdien af variabler live
    Call stack	Viser hvilke funktioner, der er kaldt, og i hvilken rÃ¦kkefÃ¸lge
    Debuggere findes i fx:

    VS Code, PyCharm, Eclipse, Xcode

    Indbygget i browserens devtools (til JS)

    CLI (fx pdb i Python, gdb i C)

**HvornÃ¥r bruger man en debugger?**

    Situation	Eksempel
    NÃ¥r programmet crasher uden tydelig Ã¥rsag	Segfault, NoneType error
    NÃ¥r noget opfÃ¸rer sig forkert	En funktion returnerer et forkert resultat
    NÃ¥r man vil forstÃ¥ andres eller egen kompleks kode	Trinvis analyse
    Ved white-box testing	NÃ¥r man systematisk tester kontrolstrukturer
## SP11
### Hvad er en black box test? Forklar princippet bag black box tests. Er det realistisk at risikere at en komplet test skal gennemfÃ¸re 10^100 kombinationsmuligheder af input vÃ¦rdier â€“ hvorfor/hvorfor ikke? Antag det er, hvordan sikrer du sÃ¥ at testen kan gennemfÃ¸res pÃ¥ realistisk kort tid? Argumenter for hvorfor din metode vil vÃ¦re bullet-proof. Ved sidste spÃ¸rgsmÃ¥l, tag gerne udgangspunkt i en lÃ¸sning fra opgave 1.
**Hvad er en Black Box Test?**

Black box test (ogsÃ¥ kaldet funktionsbaseret test) er en testmetode, hvor du tester systemets funktionalitet udefra â€“ altsÃ¥ uden at kende den interne kode eller struktur.  
**Princippet bag black box testing**

    Fokus er pÃ¥ input og output: Giver systemet det rigtige output for det givne input?

    Tester typisk:

        Funktionalitetskrav

        Brugerinteraktion

        GrÃ¦nsevÃ¦rdier

        FejlhÃ¥ndtering
**Du skriver testcases baseret pÃ¥ kravspecifikationen og tester, om programmet opfÃ¸rer sig som forventet.**    
**Er 10^100 kombinationsmuligheder â€“ realistisk?**  

Nej, det er komplet urealistisk.  

Et eksempel:  

    Forestil dig et system der tager 100 inputfelter, og hvert felt kan have 10 vÃ¦rdier â†’ 1010010100 kombinationer = mere end antallet af atomer i universet.

**SÃ¥:**

    Det er umuligt at teste alle kombinationer

    Det vil tage uendelig lang tid og regnekraft

**âœ… Hvordan tester vi alligevel pÃ¥ realistisk tid?**

Ved at bruge strategiske metoder:
1. Ã†kvivalensklasser

    Del input i grupper, hvor du forventer samme adfÃ¦rd

    Test kun Ã©n vÃ¦rdi pr. gruppe

ðŸ”§ Eksempel: Hvis alder skal vÃ¦re 18â€“100, sÃ¥ test:

    UndergrÃ¦nse: 17 (ulovlig)

    Gyldig: 25

    OvergrÃ¦nse: 101 (ulovlig)

2. GrÃ¦nsevÃ¦rditest (Boundary Value Analysis)

    Fejl sker oftest ved grÃ¦nser, fx 0, 1, max

    Test fx vÃ¦rdier: min-1, min, min+1, max-1, max, max+1

3. Fejlspekulation / Edge cases

    Brug erfaring og viden om typiske fejl

    Eksempler: tom input, null, ekstremt store/smÃ¥ tal

4. Risiko-baseret test

    PrioritÃ©r test pÃ¥ funktioner der er forretningskritiske eller fejl-udsatte

ðŸ›¡ï¸ Argument: Hvorfor er dette "bulletproof"?

Det er ikke muligt at sikre 100% korrekthed i alle situationer, men:

âœ… Disse metoder minimerer risikoen for kritiske fejl
âœ… De fokuserer indsatsen pÃ¥ de vigtigste og mest fejl-udsatte omrÃ¥der
âœ… De gÃ¸r det muligt at teste hurtigt og effektivt med hÃ¸j dÃ¦kning
âœ… Kombineret med white-box tests, fÃ¥r du bÃ¥de intern og ekstern testdÃ¦kning
ðŸ§ª Eksempel: BubbleSort fra opgave 1

Krav:

    BubbleSort skal sortere listen i stigende orden

Black box test cases:
Test Case	Input	Forventet Output
Tom liste	[]	[]
Ã‰n vÃ¦rdi	[5]	[5]
Allerede sorteret	[1, 2, 3]	[1, 2, 3]
Omvendt sorteret	[3, 2, 1]	[1, 2, 3]
DobbeltvÃ¦rdier	[2, 2, 1]	[1, 2, 2]

âš ï¸ BemÃ¦rk: Her kender vi ikke hvordan koden er lavet (black box), men vi ved hvordan den skal opfÃ¸re sig.
### Hvis noget kode ser ud til at virke, er du sÃ¥ helt sikker? Hvordan sikrer du dig, at du ogsÃ¥ vil have den kode til at vÃ¦re ansvarlig for nÃ¦ste flytur du selv skal pÃ¥? Beskriv hvordan du fandt fejlen i det kode der blev givet i opgave 2. Er du sikker pÃ¥ du fandt ALLE fejl? Argumenter hvorfor du er sikke
**Hvis noget kode ser ud til at virke â€“ er man sÃ¥ helt sikker?**  

Nej â€“ aldrig.  

At koden ser ud til at virke, betyder kun, at den virker i de tilfÃ¦lde, du har testet den.  

    Men hvad med alle de utestede situationer, inputkombinationer, kanttilfÃ¦lde eller fejlscenarier?

NÃ¥r det handler om kritiske systemer, som fx en flyver, sÃ¥ er â€œdet virker pÃ¥ min maskineâ€ ikke godt nok.
âœ… Hvordan sikrer man sig kvalitet og sikkerhed?

    Grundig test:

        Brug bÃ¥de black box og white box tests

        Test grÃ¦nsetilfÃ¦lde, fejlscenarier, store input, tomme input, uventede input

    Code review:

        Flere Ã¸jne opdager flere fejl

        Du fÃ¥r feedback pÃ¥ bÃ¥de logik og struktur

    Statisk analyse:

        Brug vÃ¦rktÃ¸jer der automatisk analyserer koden for potentielle fejl (f.eks. pylint, mypy, flake8)

    Formal verification (i kritiske systemer):

        Matematiske beviser for at koden opfÃ¸rer sig korrekt

    Test coverage:

        Hvor meget af koden bliver faktisk ramt af tests? (Fx med coverage.py)

ðŸ› Hvordan fandt vi fejlene i opgave 2?

Vi gennemgik koden linje for linje, og:

    Brugte white-box teknik til at se pÃ¥ intern logik

    Spottede:

        Forkert abs(...) brugt i sammenligning

        Forkert initialisering og opdatering af swapped i bubble sort

        Logiske fejl i rekursiv tilgang â†’ risiko for uendelig lÃ¸kke

        MisforstÃ¥else af sorteringsretning

        Manglende input() validering

â“Er vi sikre pÃ¥, at vi har fundet ALLE fejl?

Nej â€“ men vi har reduceret risikoen betydeligt.

Vi kan ikke 100% garantere, at der aldrig er fejl. Der kan stadig vÃ¦re:

    Edge cases vi ikke har testet

    Performance-problemer pÃ¥ store inputs

    Fejl ved flydende tal, NaN, inf, etc.

Men:

    Vi har anvendt systematiske metoder

    Vi har lavet grundige test og kontrol

    Og vi har lavet logiske forbedringer i strukturen

Det gÃ¸r os trygge ved funktionaliteten, men vi ville stadig ikke bruge det i en flyver uden meget mere test og certificering.
ðŸ§  Konklusion

    At vÃ¦re professionel udvikler betyder ikke at â€œtroâ€ koden virker â€“ det betyder at dokumentere og teste, indtil man ved, at den virker â€” i hvert fald under de definerede krav og forudsÃ¦tninger.

